package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/btcsuite/btcd/btcec"
	"github.com/btcsuite/btcd/chaincfg"
	"github.com/fiatjaf/lightningd-gjson-rpc/plugin"
	"github.com/lightningnetwork/lnd/zpay32"
)

func main() {
	p := plugin.Plugin{
		Name:    "invoicewithdescriptionhash",
		Version: "v1.2",
		Options: []plugin.Option{},
		RPCMethods: []plugin.RPCMethod{
			{
				Name:            "invoicewithdescriptionhash",
				Usage:           "msatoshi label description_hash [expiry] [preimage]",
				Description:     "Create an invoice for {msatoshi} with {label} and {description_hash} with optional {expiry} seconds (default 1 week) and optional {preimage} (default autogenerated)",
				LongDescription: "",
				Handler: func(p *plugin.Plugin, params plugin.Params) (resp interface{}, errCode int, err error) { // gather params
					msatoshi, err := params.Int("msatoshi")
					if err != nil {
						return nil, 400, errors.New("invalid msatoshi value")
					}

					expiry, _ := params.Int("expiry")

					var bpreimage []byte
					if preimage, err := params.String("preimage"); err == nil {
						bpreimage, _ = hex.DecodeString(preimage)
					} else {
						bpreimage = make([]byte, 32)
						rand.Read(bpreimage)
					}
					rhash := sha256.Sum256(bpreimage)

					descriptionHashHex := params.Get("description_hash").String()
					descriptionHash, _ := hex.DecodeString(descriptionHashHex)

					if len(descriptionHash) != 32 {
						return nil, 477,
							errors.New("description_hash is invalid or not given")
					}

					// create an invoice at the node so it expects for a payment at this hash
					// we won't expose this, but it will still get paid
					invoiceParams := map[string]interface{}{
						"label":       params.Get("label").String(),
						"msatoshi":    msatoshi,
						"preimage":    hex.EncodeToString(bpreimage),
						"description": fmt.Sprintf("with description hash '%s'", descriptionHashHex),
					}
					if expiry != 0 {
						invoiceParams["expiry"] = expiry
					}
					inv, err := p.Client.Call("invoice", invoiceParams)
					if err != nil {
						err = fmt.Errorf("failed to call 'invoice' on lightningd: %w", err)
						return
					}

					// now create another invoice, this time with the desired description_hash instead
					bolt11 := inv.Get("bolt11").String()
					firstNumber := strings.IndexAny(bolt11, "1234567890")
					chainPrefix := bolt11[2:firstNumber]
					chain := &chaincfg.Params{
						Bech32HRPSegwit: chainPrefix,
					}
					invoice, err := zpay32.Decode(bolt11, chain)
					if err != nil {
						err = fmt.Errorf("failed to decode '%s' received from lightningd with zpay32: %w",
							bolt11, err)
						return
					}

					// replace the description in the parsed invoice with the description hash
					invoice.Description = nil
					invoice.Destination = nil
					var descriptionHash32 [32]byte
					copy(descriptionHash32[:], descriptionHash)
					invoice.DescriptionHash = &descriptionHash32

					// finally sign this new invoice using a key we hackishly grab from lightningd's hsm_secret
					privKey, err := p.Client.GetPrivateKey()
					if err != nil {
						err = fmt.Errorf("failed to get private key from hsm_secret: %w", err)
						return
					}

					translatedBolt11, err := invoice.Encode(zpay32.MessageSigner{
						SignCompact: func(hash []byte) ([]byte, error) {
							return btcec.SignCompact(btcec.S256(), privKey, hash, true)
						},
					})
					if err != nil {
						err = fmt.Errorf("failed to sign translated invoice: %w", err)
						return
					}

					return map[string]interface{}{
						"bolt11":           translatedBolt11,
						"description_hash": hex.EncodeToString(descriptionHash),
						"preimage":         hex.EncodeToString(bpreimage),
						"payment_hash":     hex.EncodeToString(rhash[:]),
						"expires_at": time.Now().
							Add(time.Duration(expiry) * time.Second).Unix(),
					}, 0, nil
				},
			},
		},
	}
	p.Run()
}
